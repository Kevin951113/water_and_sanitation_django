{% extends "base.html" %}
{% load static %}

{% block title %}Animal Map | Water & Sanitation{% endblock %}

{% block head_extras %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

<style>
  :root { --am-card-bg:#fff; --am-text:#111; --am-muted:#555; --am-border:#ddd; }
  :root[data-theme="dark"] { --am-card-bg:#0f172a; --am-text:#e5e7eb; --am-muted:#94a3b8; --am-border:#334155; }

  .am-shell{max-width:1400px;margin:0 auto;padding:0 14px;}
  .am-section{margin-bottom:30px;}
  .am-card{background:var(--am-card-bg); color:var(--am-text); border:1px solid var(--am-border); border-radius:14px; padding:18px; box-shadow:0 2px 10px rgba(0,0,0,.08);}
  .am-card h2{margin:0 0 8px;font-size:1.3rem;}
  .am-muted{color:var(--am-muted);}
  .am-split{display:grid;grid-template-columns:minmax(0,1fr) 340px;gap:14px;}
  @media(max-width:1000px){.am-split{grid-template-columns:1fr}}
  .am-map{width:100%;height:500px;border-radius:12px;background:#eef;}
  .am-aside{border:1px solid var(--am-border); border-radius:12px; padding:10px; background:var(--am-card-bg); overflow:auto; max-height:520px; position:sticky; top:12px;}
  .am-aside h3{font-size:1rem;margin:0 0 8px;}
  .am-gallery{display:flex;flex-direction:column;gap:10px;}
  .am-figure{cursor:pointer; display:flex; align-items:center; gap:12px; padding:8px; border-radius:8px; border:1px solid transparent; color:var(--am-text); background:transparent;}
  .am-figure:hover{background:rgba(0,0,0,0.05); border-color:var(--am-border);}
  :root[data-theme="dark"] .am-figure:hover{background:rgba(255,255,255,0.05);}
  .am-figure img{display:block; max-width:140px; height:auto; object-fit:contain}
  .am-toolbar{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0;align-items:center;}
  .am-select{border:1px solid var(--am-border); border-radius:8px; padding:8px 10px; min-width:220px; background:var(--am-card-bg); color:var(--am-text);}
  .am-btn{border:1px solid var(--am-border); background:var(--am-card-bg); padding:8px 10px; border-radius:8px; cursor:pointer; color:var(--am-text);}
  .am-btn:hover{filter:brightness(1.05);}
  .am-count{margin-left:auto; color:var(--am-muted); font-size:.9rem;}
  .am-quest{display:flex; align-items:center; gap:10px; padding:6px 10px; border:1px dashed var(--am-border); border-radius:10px; background:var(--am-card-bg);}
  .am-quest .am-bar{ width:160px; height:10px; background:#e5e7eb; border-radius:6px; overflow:hidden;}
  :root[data-theme="dark"] .am-quest .am-bar{ background:#1f2937; }
  .am-quest .am-bar > i{ display:block; height:100%; width:0%; background:#34d399; }

  /* Popup card in map */
  .am-popup{ max-width:300px; }
  .am-popup img{ width:100%; height:auto; border-radius:12px; margin-bottom:8px; }
  .am-popup h4{ margin:0 0 6px; font-size:1.2rem; line-height:1.3; }
  .am-popup p{ margin:2px 0; font-size:1rem; line-height:1.25; }
  .am-popup p.small{ font-size:.95rem; opacity:.9; }

  .am-toast{ position:fixed; left:50%; top:16px; transform:translateX(-50%); background:#111; color:#fff; padding:10px 14px; border-radius:10px; z-index:9999; opacity:.95; box-shadow:0 4px 12px rgba(0,0,0,.25); }

  /* ------- Marker rendering with L.divIcon (no drop-shadow) ------- */
  .am-ico{ background:transparent; border:0; }
  .am-ico > img{ display:block; width:100%; height:100%; border-radius:8px; transform:scale(1); transition:transform .18s ease; }
  .am-ico > img.am-highlight{
    animation: amPop .9s ease-out 1;
    filter: drop-shadow(0 0 10px rgba(34,211,238,.95)) drop-shadow(0 0 18px rgba(59,130,246,.55));
  }
  @keyframes amPop{
    0%{transform:scale(1) translateY(0)}
    35%{transform:scale(1.18) translateY(-4px)}
    70%{transform:scale(1.08) translateY(-2px)}
    100%{transform:scale(1) translateY(0)}
  }

  /* ===== My Animal Cards (front/back flip with subtle shine) ===== */
  .am-collection-wrap{ display:flex; gap:12px; flex-wrap:wrap; }

  .am-badge{ margin-left:8px; padding:2px 8px; border-radius:999px; font-size:.85rem; background:#e5f5ff; color:#0369a1; }
  :root[data-theme="dark"] .am-badge{ background:#082f49; color:#7dd3fc; }

  /* Outer wrapper → vertical float only */
  .am-cardflip{
    width:120px; height:160px; perspective:900px;
    animation: amCardFloat 4.5s ease-in-out infinite;
  }

  /* Inner: holds front/back faces, does the Y-rotation */
  .am-inner{
    position:relative; width:100%; height:100%;
    border-radius:14px; border:3px solid rgba(255,255,255,.9);
    box-shadow:0 6px 18px rgba(0,0,0,.25);
    transform-style:preserve-3d;
    animation: amFlipCycle 5.5s ease-in-out infinite;
    background:#000;
    overflow:hidden;
  }

  /* Subtle shine passing across the card while flipping */
  .am-inner::after{
    content:"";
    position:absolute; inset:-2px;
    border-radius:inherit;
    background:linear-gradient(75deg, rgba(255,255,255,0) 40%, rgba(255,255,255,.22) 50%, rgba(255,255,255,0) 60%);
    transform:translateX(-120%);
    pointer-events:none;
    animation: amShine 5.5s ease-in-out infinite;
  }

  .am-front,.am-back{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    border-radius:12px;
    backface-visibility:hidden;
    -webkit-backface-visibility:hidden;
  }
  .am-front{ background:#000; }
  .am-front img{ width:100%; height:100%; object-fit:contain; }
  .am-back{
    transform:rotateY(180deg);
    background:#020617; color:#e5e7eb;
    padding:8px; text-align:center; line-height:1.2; font-size:.92rem;
  }
  .am-back .small{ opacity:.9; font-size:.85rem; }

  /* --- IMPORTANT: remove per-card hover pause; we'll control globally via JS --- */
  .am-cardflip:hover{ animation-play-state:inherit; }
  .am-cardflip:hover .am-inner{ animation-play-state:inherit; }
  .am-cardflip:hover .am-inner::after{ animation-play-state:inherit; }

  /* Flip goes 0 → 180 → 0 to clearly show both faces */
  @keyframes amFlipCycle {
    0%   { transform: rotateY(0deg); }
    50%  { transform: rotateY(180deg); }
    100% { transform: rotateY(360deg); }
  }

  /* Shine sweeps across near the mid-flip */
  @keyframes amShine{
    0%,25%   { transform:translateX(-120%); }
    40%      { transform:translateX(120%); }
    100%     { transform:translateX(120%); }
  }

  /* Gentle floating */
  @keyframes amCardFloat{
    0%,100%{ transform:translateY(0); }
    50%    { transform:translateY(-6px); }
  }

  /* Pop-in when a new card is earned */
  .am-pop-in{ animation: amPopIn .5s ease-out 1; }
  @keyframes amPopIn{
    0%{ transform:scale(.8); opacity:0 }
    60%{ transform:scale(1.05); opacity:1 }
    100%{ transform:scale(1); }
  }

  /* ---------- Global control states for collection ---------- */
  /* Pause ALL animations */
  .am-collection-wrap.am-all-paused .am-cardflip,
  .am-collection-wrap.am-all-paused .am-inner,
  .am-collection-wrap.am-all-paused .am-inner::after{
    animation-play-state: paused !important;
  }
  /* Force face-front (0deg) and stop shine during reset */
  .am-collection-wrap.am-face-front .am-cardflip{
    animation: none !important;
  }
  .am-collection-wrap.am-face-front .am-inner{
    animation: none !important;
    transform: rotateY(0deg) !important;
  }
  .am-collection-wrap.am-face-front .am-inner::after{
    animation: none !important;
    transform: translateX(-120%) !important;
  }
</style>
{% endblock %}

{% block content %}
<section class="am-shell am-section">
  <div class="am-card">
    <h2>Animal Sightings Map</h2>
    <p class="am-muted">Look! Find animals near the water.</p>

    <div class="am-toolbar">
      <select id="am-select" class="am-select" aria-label="Choose animal">
        <option value="">Choose animal…</option>
      </select>

      <button id="am-reload" class="am-btn" type="button">Reload</button>
      <button id="am-clear-view" class="am-btn" type="button" title="Reset view">Clear View</button>
      <button id="am-reset-score" class="am-btn" type="button" title="Reset your score">Reset Score</button>

      <div id="am-quest" class="am-quest" aria-live="polite">
        ⭐ Found <b id="am-found">0</b> species —
        Score <b id="am-score">0</b>/100
        <div class="am-bar"><i id="am-bar"></i></div>
        <span id="am-milestone" class="am-muted" style="font-size:.9rem;">Score milestones: 25 / 50 / 75 / 100</span>
        <span id="am-badge" class="am-badge" style="display:none;"></span>
      </div>

      <span id="am-count" class="am-count" aria-live="polite"></span>
    </div>

    <div class="am-split">
      <div>
        <div id="am-map" class="am-map" role="region" aria-label="Animal sightings map"></div>
        <p id="am-empty" class="am-muted" style="text-align:center;display:none;">No animals found.</p>
        <p id="am-loading" class="am-muted" style="text-align:center;">Loading…</p>
      </div>
      <aside class="am-aside">
        <h3>All Animals <span id="am-gallery-count" class="am-muted"></span></h3>
        <div id="am-gallery" class="am-gallery"></div>
      </aside>
    </div>
  </div>
</section>

<!-- My Animal Cards Collection -->
<section id="am-collection" class="am-shell am-section">
  <div class="am-card">
    <h2>My Animal Cards <small class="am-muted">These are the animals you've found!</small></h2>
    <div id="am-card-collection" class="am-collection-wrap" aria-live="polite"></div>
  </div>
</section>
{% endblock %}

{% block page_scripts %}
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
/* -------------------------- DOM refs -------------------------- */
const $ = (id) => document.getElementById(id);
const els = { map:$("am-map"), select:$("am-select"), reload:$("am-reload"), clearView:$("am-clear-view"),
  resetScore:$("am-reset-score"), empty:$("am-empty"), loading:$("am-loading"), count:$("am-count"),
  gallery:$("am-gallery"), gcount:$("am-gallery-count"), found:$("am-found"), score:$("am-score"),
  bar:$("am-bar"), cards:$("am-card-collection"), badge:$("am-badge") };

/* -------------------------- Map & state -------------------------- */
let leafletMap, clusterLayer, allItems = [], galleryAll = [];
let totalSpecies = 35;
const speciesFirstMarker = new Map();
let defaultCenter = [-37.8,145], defaultZoom = 7;
let lineUpLayer = null;

/* -------------------------- Persistence -------------------------- */
const LS_DISC="am_discovered_v2", LS_SCORE_M="am_score_milestones_v1", LS_CARDS="am_cards_v1";
let discovered = new Set(JSON.parse(localStorage.getItem(LS_DISC) || "[]"));
let scoreMilestonesDone = new Set(JSON.parse(localStorage.getItem(LS_SCORE_M) || "[]"));
let collectedCards = JSON.parse(localStorage.getItem(LS_CARDS) || "[]"); // [{name, img}]
function saveProgress(){ localStorage.setItem(LS_DISC, JSON.stringify([...discovered])); localStorage.setItem(LS_SCORE_M, JSON.stringify([...scoreMilestonesDone])); }
function saveCards(){ localStorage.setItem(LS_CARDS, JSON.stringify(collectedCards)); }

/* -------------------------- Score helpers -------------------------- */
function computeScore(){ if(!totalSpecies) return 0; return Math.round(Math.min(100,(discovered.size/totalSpecies)*100)); }
function updateQuestUI(){ els.found.textContent=discovered.size; const s=computeScore(); els.score.textContent=s; els.bar.style.width=s+"%"; updateBadge(); }
const SCORE_MILESTONES=[25,50,75,100];
function checkScoreMilestones(){
  const s = computeScore();
  SCORE_MILESTONES.forEach(m=>{
    if(s>=m && !scoreMilestonesDone.has(m)){
      scoreMilestonesDone.add(m);
      Swal.fire({title:(m===100)?"Amazing! 100/100!":`Great job — ${m} points!`,
                 text:(m===100)?"You found them all. You're a Water Hero!":"Keep going! Can you reach the next badge?",
                 icon:"success",confirmButtonText:"OK",draggable:true});
    }
  });
  saveProgress();
}
/* Cute title badge: 10=Explorer, 25=Eco Hero, 35=Water Guardian */
function updateBadge(){
  const n = discovered.size;
  let title = "";
  if(n >= 35) title = "🏆 Water Guardian";
  else if(n >= 25) title = "🌟 Eco Hero";
  else if(n >= 10) title = "🎒 Explorer";
  els.badge.textContent = title;
  els.badge.style.display = title ? "inline-block" : "none";
}

/* -------------------------- Text helpers -------------------------- */
const ONE_LINERS={"bottlenose dolphin":"I leap high!","eastern blue groper":"Big blue pal","eastern fiddler ray":"Striped ray","eastern king prawn":"Swift swimmer","eastern rock lobster":"Spiky pal","giant cuttlefish":"Colour magic!","green turtle":"Gentle diver","grey morwong":"Calm swimmer","leatherback turtle":"Ocean giant","loggerhead turtle":"Strong shell","luderick":"Sea grazer","mosaic leatherjacket":"Funny jacket","old wife":"Two spines!","onespot puller":"One spot hero","pacific ridley turtle":"Little rider","red morwong":"Red stripes","red velvetfish":"Velvet fins","rock blackfish":"Rock shadow","rock cale":"Rock grazer","scissortail sergeant":"Snip-tail!","sergeant baker":"Long swimmer","short boarfish":"Short snout","silver drummer":"Silver flash","snapper":"Pink spiky","southern fiddler ray":"Spotty ray","southern maori wrasse":"Curvy lines","southern right whale":"Gentle giant","spotted grubfish":"Dotty friend","tiger shark":"Big stripes","warty prowfish":"Bumpy body","western blue groper":"Big blue pal","whiskered prowfish":"Whisker fins","whitebarred boxfish":"Boxy body","white-ear":"White ear dot","yellow-bellied seasnake":"Yellow belly"};
const HABITATS={"bottlenose dolphin":"bays and open seas","southern right whale":"cold southern waters","tiger shark":"coastal and offshore seas","green turtle":"bays and seagrass beds","leatherback turtle":"open ocean","loggerhead turtle":"bays and reefs","pacific ridley turtle":"warm currents and bays","eastern fiddler ray":"sandy bays","southern fiddler ray":"sandy bays","giant cuttlefish":"reefs and seagrass","eastern rock lobster":"rocky reefs","eastern king prawn":"estuaries and sandy bottoms","eastern blue groper":"rocky reefs","western blue groper":"rocky reefs","grey morwong":"reefs","red morwong":"reefs","rock blackfish":"reefs","rock cale":"reefs and weed beds","luderick":"estuaries and seagrass","mosaic leatherjacket":"reefs and weed beds","old wife":"reefs","onespot puller":"reefs","red velvetfish":"reefs","scissortail sergeant":"reefs","sergeant baker":"sandy reefs","short boarfish":"reefs","silver drummer":"surf reefs","snapper":"bays and reefs","southern maori wrasse":"reefs","spotted grubfish":"sandy bottoms","warty prowfish":"weed reefs","whiskered prowfish":"weed reefs","whitebarred boxfish":"reefs and seagrass","white-ear":"rocky reefs","yellow-bellied seasnake":"offshore waters"};
const normName=(n)=>(n||"").toString().trim().toLowerCase();

/* Helper: build back text from species name */
function infoFor(name){
  const key = normName(name);
  return {
    line: ONE_LINERS[key] || "I love clean seas.",
    home: HABITATS[key] || "bays and reefs"
  };
}

function popupHtml(it){
  const name = it.common_name || "Unknown";
  const key  = normName(name);
  const line = ONE_LINERS[key] || "I love clean seas.";
  const home = HABITATS[key]   || "bays and reefs";
  const photo = it.photo_url || it.icon_url || "";
  return `<div class="am-popup">${photo?`<img src="${photo}" alt="${name}" loading="lazy"/>`:""}
    <h4>${name}</h4><p><strong>${line}</strong></p><p class="small">I live in <em>${home}</em>.</p></div>`;
}

/* -------------------------- Icon helpers -------------------------- */
function makeIcon(url, size=40){
  return L.divIcon({ className:'am-ico', html:`<img src="${url}" alt="">`, iconSize:[size,size], iconAnchor:[size/2,size/2], popupAnchor:[0,-size/2] });
}
function highlightOnly(marker){
  document.querySelectorAll('.am-ico > img.am-highlight').forEach(img=>img.classList.remove('am-highlight'));
  const root = marker._icon || (marker.getElement && marker.getElement());
  if(!root) return;
  const img = root.querySelector('img');
  if(!img) return;
  img.classList.remove('am-highlight'); void img.offsetWidth; // restart animation
  img.classList.add('am-highlight');
}

/* -------------------------- GLOBAL CARD CONTROL (pause->face-front->resume) -------------------------- */
let hoverResumeTimer=null, addCardResumeTimer=null;

function getCardNodes(){ return els.cards ? els.cards.querySelectorAll('.am-cardflip') : []; }

/** Put all cards into paused + face-front state. */
function globalPauseFaceFront(){
  if(!els.cards) return;
  els.cards.classList.add('am-all-paused','am-face-front');
}

/** Resume flipping for all cards (with a small reflow to restart CSS animations cleanly). */
function globalResumeFlipping(){
  if(!els.cards) return;
  // release face-front first so transform returns to animation control
  els.cards.classList.remove('am-face-front');
  // restart animations by toggling style
  getCardNodes().forEach(card=>{
    const inner = card.querySelector('.am-inner');
    // float wrapper
    card.style.animation='none';
    // flip inner
    if(inner){ inner.style.animation='none'; }
    // reflow
    void card.offsetHeight;
    // restore
    card.style.animation='';
    if(inner){ inner.style.animation=''; }
  });
  // finally unpause
  els.cards.classList.remove('am-all-paused');
}

/* -------------------------- Cards: DOM builder, render & add -------------------------- */
function buildCardNode(name, img){
  const { line, home } = infoFor(name);

  const wrap = document.createElement("div");
  wrap.className = "am-cardflip";

  const inner = document.createElement("div");
  inner.className = "am-inner";
  wrap.appendChild(inner);

  const front = document.createElement("div");
  front.className = "am-front";
  const pic = document.createElement("img");
  pic.src = img; pic.alt = name;
  front.appendChild(pic);

  const back = document.createElement("div");
  back.className = "am-back";
  back.innerHTML = `<div><strong>${name}</strong><br><span class="small">${line}</span><br><span class="small">Home: ${home}</span></div>`;

  inner.appendChild(front);
  inner.appendChild(back);
  return wrap;
}

function renderCards(){
  els.cards.innerHTML = "";
  collectedCards.forEach(c=>{
    const node = buildCardNode(c.name, c.img);
    els.cards.appendChild(node);
  });
}

/** Add a card with global pause->front->append->resume flow */
function addCollectedCard(it){
  const name = (it.common_name||"").trim();
  if(!name) return;
  if(collectedCards.some(c=>c.name===name)) return; // already have it
  const img = it.photo_url || it.icon_url || "";
  collectedCards.push({name, img});
  saveCards();

  // Global pause and face-front BEFORE inserting
  clearTimeout(addCardResumeTimer);
  globalPauseFaceFront();

  const node = buildCardNode(name, img);
  node.classList.add("am-pop-in");
  els.cards.appendChild(node);

  // ensure DOM paint then resume
  requestAnimationFrame(()=> {
    addCardResumeTimer = setTimeout(()=> {
      globalResumeFlipping();
    }, 550); // wait a moment so the new card is visually seen
  });
}

/* -------------------------- Cluster (spiderfy) -------------------------- */
const CLUSTER_OPTS = {
  showCoverageOnHover:false,
  zoomToBoundsOnClick:false,
  spiderfyOnEveryClick:true,
  spiderfyOnMaxZoom:true,
  spiderfyDistanceMultiplier:2.4,
  spiderLegPolylineOptions:{weight:1.5,opacity:0.9,color:'#22d3ee'},
  maxClusterRadius:70, chunkedLoading:true, removeOutsideVisibleBounds:true
};

function initMap(meta){
  if(!leafletMap){
    const center=(meta&&meta.victoria_coords)||defaultCenter;
    const z=(meta&&meta.default_zoom)||defaultZoom;
    defaultCenter=center.slice?center.slice():center; defaultZoom=z;
    leafletMap=L.map("am-map",{doubleClickZoom:false}).setView(defaultCenter,defaultZoom);
    L.tileLayer((meta&&meta.tile_url)||"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                {attribution:(meta&&meta.tile_attribution)||"© OpenStreetMap"}).addTo(leafletMap);
    leafletMap.on("dragstart", clearTempViews);
    leafletMap.on("zoomstart", clearTempViews);
  }
  if(clusterLayer){ clusterLayer.clearLayers(); if(leafletMap.hasLayer(clusterLayer)) leafletMap.removeLayer(clusterLayer); }
  clusterLayer=L.markerClusterGroup(CLUSTER_OPTS).addTo(leafletMap);
}

/* -------------------------- Discovery on popup -------------------------- */
function attachDiscoveryOnPopup(marker, item){
  marker.on("popupopen", ()=>{
    // Visual highlight on the marker
    highlightOnly(marker);

    const cname=(item.common_name||"").trim();
    if(cname && !discovered.has(cname)){
      // First time discovery → score, badge, toast, and add a card
      discovered.add(cname); saveProgress(); updateQuestUI(); checkScoreMilestones();
      addCollectedCard(item);
      const t=document.createElement("div"); t.className="am-toast"; t.textContent=`+1 Found: ${cname}`;
      document.body.appendChild(t); setTimeout(()=>t.remove(),1200);
    }
  });
}

/* -------------------------- Markers -------------------------- */
function renderMarkers(items){
  clusterLayer.clearLayers();
  speciesFirstMarker.clear();
  const seenFirst = new Set();
  const markers = [];

  items.forEach(it=>{
    const lat = Number(it.latitude), lon = Number(it.longitude);
    if(Number.isNaN(lat) || Number.isNaN(lon)) return;

    const icon = it.icon_url ? makeIcon(it.icon_url, 40) : undefined;
    const m = L.marker([lat, lon], icon?{icon}:undefined)
      .bindPopup(popupHtml(it), { maxWidth: 320, keepInView: true, autoPan: true });

    m.on('click', ()=> highlightOnly(m));
    attachDiscoveryOnPopup(m, it);

    const sp=(it.common_name||"").trim();
    if(sp && !seenFirst.has(sp)){ seenFirst.add(sp); speciesFirstMarker.set(sp,m); }
    markers.push(m);
  });

  if(markers.length){ clusterLayer.addLayers(markers); els.empty.style.display="none"; }
  else { els.empty.style.display="block"; }
  els.count.textContent = markers.length + " found";
}

/* -------------------------- Line-Up (per species) -------------------------- */
const LINE_UP_SPACING=0.003, LINE_UP_LAT_SHIFT=0.0;
function clearLineUp(){
  if (!leafletMap) return;
  if (lineUpLayer && leafletMap.hasLayer(lineUpLayer)) leafletMap.removeLayer(lineUpLayer);
  lineUpLayer = null;
  if (clusterLayer && !leafletMap.hasLayer(clusterLayer)) leafletMap.addLayer(clusterLayer);
}
function lineUpSpecies(name){
  const matches = allItems.filter(it => it.common_name === name);
  if(!matches.length) return;

  clearLineUp();
  if (leafletMap.hasLayer(clusterLayer)) leafletMap.removeLayer(clusterLayer);

  const lats=[], lons=[];
  matches.forEach(it=>{
    const la=Number(it.latitude), lo=Number(it.longitude);
    if(!Number.isNaN(la)&&!Number.isNaN(lo)){ lats.push(la); lons.push(lo); }
  });
  const avgLat = lats.reduce((a,b)=>a+b,0)/lats.length || defaultCenter[0];
  const avgLon = lons.reduce((a,b)=>a+b,0)/lons.length || defaultCenter[1];

  const n = matches.length;
  const start = avgLon - ((n-1) * LINE_UP_SPACING / 2);
  const temp = [];

  matches.forEach((it,i)=>{
    const lat = avgLat + (i-(n-1)/2) * LINE_UP_LAT_SHIFT;
    const lon = start + i * LINE_UP_SPACING;

    const icon = it.icon_url ? makeIcon(it.icon_url, 44) : undefined;
    const m = L.marker([lat,lon], icon?{icon}:undefined)
      .bindPopup(popupHtml(it), { maxWidth: 320, keepInView: true, autoPan: false });

    m.on('click', ()=> highlightOnly(m));
    attachDiscoveryOnPopup(m, it);
    temp.push(m);
  });

  lineUpLayer = L.layerGroup(temp).addTo(leafletMap);

  setTimeout(()=>{ if(temp[0]){ highlightOnly(temp[0]); temp[0].openPopup(); } }, 120);

  const b = lineUpLayer.getBounds();
  leafletMap.fitBounds(b, { padding:[30,30] });
}

/* -------------------------- Gallery & Select -------------------------- */
function buildGallery(payload){
  const raw = Array.isArray(payload.gallery) ? payload.gallery : [];
  if(raw.length) return raw;
  const seen = new Set(), list = [];
  (payload.items || []).forEach(it=>{
    const name = it.common_name || "Unknown";
    const key = name + "||" + (it.icon_url || "");
    if(seen.has(key)) return;
    seen.add(key);
    list.push({ common_name:name, icon_url:it.icon_url||"", photo_url:it.photo_url||"" });
  });
  return list;
}
function renderGallery(gallery){
  galleryAll = Array.isArray(gallery) ? gallery : [];
  galleryAll.sort((a,b)=> (a.common_name||"").localeCompare(b.common_name||"", undefined, {sensitivity:"base"}));
  els.gallery.innerHTML = "";
  els.select.innerHTML = '<option value="">Choose animal…</option>';

  galleryAll.forEach(g=>{
    const opt = document.createElement("option");
    opt.value = g.common_name;
    opt.textContent = g.common_name;
    els.select.appendChild(opt);

    const row = document.createElement("button");
    row.type="button";
    row.className="am-figure";
    row.innerHTML = `<img src="${g.icon_url || g.photo_url}" alt="${g.common_name}" loading="lazy"/><div><strong>${g.common_name}</strong></div>`;
    row.onclick = ()=> lineUpSpecies(g.common_name);
    els.gallery.appendChild(row);
  });

  totalSpecies = galleryAll.length || totalSpecies;
  $("am-gallery-count").textContent = totalSpecies ? `(${totalSpecies})` : "";
  updateQuestUI();
}

/* -------------------------- Data loading -------------------------- */
async function loadData(){
  els.loading.style.display="block"; els.empty.style.display="none";
  try{
    const res = await fetch("{% url 'animal_map_data' %}");
    const payload = await res.json();

    allItems = Array.isArray(payload.items) ? payload.items : [];
    initMap(payload.meta || {});
    clearTempViews();
    renderMarkers(allItems);

    const gallery = buildGallery(payload);
    renderGallery(gallery);
    updateQuestUI();

    // Render any previously collected cards from localStorage
    renderCards();
  }catch(e){
    console.error("animal_map_data failed:", e);
    els.empty.style.display="block";
  }
  els.loading.style.display="none";
}

/* -------------------------- Events -------------------------- */
function clearTempViews(){ clearLineUp(); }

function bindCardHoverGlobal(){
  if(!els.cards) return;
  els.cards.addEventListener('mouseover', (e)=>{
    const card = e.target.closest('.am-cardflip');
    if(!card || !els.cards.contains(card)) return;
    clearTimeout(hoverResumeTimer);
    globalPauseFaceFront();
  });
  els.cards.addEventListener('mouseleave', ()=>{
    clearTimeout(hoverResumeTimer);
    hoverResumeTimer = setTimeout(()=>{ globalResumeFlipping(); }, 400);
  });
}

function bindEvents(){
  els.select.onchange = ()=>{ const name = els.select.value; if(!name) return; lineUpSpecies(name); };
  els.clearView.onclick = ()=>{
    if (leafletMap) leafletMap.closePopup();
    clearTempViews();
    if (leafletMap) leafletMap.setView(defaultCenter, defaultZoom);
    document.querySelectorAll('.am-ico > img.am-highlight').forEach(img=>img.classList.remove('am-highlight'));
  };
  els.reload.onclick = ()=> loadData();
  els.resetScore.onclick = async ()=>{
    const r = await Swal.fire({title:"Reset your score?",text:"This will clear your discovered animals and cards.",
      icon:"warning",showCancelButton:true,confirmButtonText:"Yes, reset",cancelButtonText:"No",draggable:true});
    if(r.isConfirmed){
      discovered = new Set(); scoreMilestonesDone = new Set(); saveProgress();
      collectedCards = []; saveCards(); renderCards();
      updateQuestUI();
      Swal.fire({title:"All set!",text:"Progress is reset. Have fun!",icon:"success",draggable:true});
    }
  };

  bindCardHoverGlobal();
}

/* -------------------------- Boot -------------------------- */
window.pageInit = function(){ bindEvents(); updateQuestUI(); loadData(); };
document.addEventListener("DOMContentLoaded", window.pageInit);
</script>
{% endblock %}
