{% load static %}
<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>{% block title %}[Water and Sanitation]{% endblock %}</title>
  <link rel="icon" type="image/png" href="{% static 'lighton_logo.png' %}">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- We boot the theme super early, so we avoid the flash... and we read localStorage... then we set data-theme. -->
  <script>
    (function () {
      try {
        var saved = localStorage.getItem('theme'); // 'light' | 'dark' | null
        var isLight;
        if (saved === 'light')      { isLight = true; }   // we remember the choice and respect it
        else if (saved === 'dark')  { isLight = false; }  // and if it’s dark we keep it dark
        else {
          // we fall back to OS preference, so the page feels native, then we apply it
          isLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
        }
        document.documentElement.setAttribute('data-theme', isLight ? 'light' : 'dark');
      } catch(e) { /* we keep silent because this is just UX sugar */ }
    })();
  </script>

  <!-- We import Bootstrap just for the navbar collapse... and it’s tiny... so we’re fine. -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- We preload a few images so the header looks crisp... and the loading mask feels instant. -->
  <link rel="preload" href="{% static 'lightoff_logo.png' %}" as="image">
  <link rel="preload" href="{% static 'lighton_logo.png' %}" as="image">
  <link rel="preload" href="{% static 'giphy1.gif' %}" as="image"><!-- loading GIF -->
  <!-- We also preload the vessels, so the first sail is smooth, then the animation starts nicely. -->
  <link rel="preload" href="{% static 'submarine.gif' %}" as="image">
  <link rel="preload" href="{% static 'boat.gif' %}" as="image">

  {% block head_extras %}{% endblock %}

  <!-- We moved inline styles to a proper static file, so caching works and diffs are cleaner. -->
  <link rel="stylesheet" href="{% static 'css/base.css' %}">

  <link href="https://fonts.googleapis.com/css2?family=Joti+One&display=swap" rel="stylesheet">

</head>
<body>
  <!-- We keep the header sticky, and we keep it light, so navigation feels stable. -->
  <header id="siteHeader" class="container-fluid">
    <div class="d-flex align-items-center w-100 gap-2 position-relative">
      <!-- Brand: we show the platypus logo, and we keep it responsive, so it scales on phones. -->
      <div class="brand text-center text-lg-start" aria-label="Brand">
        <span class="logo" aria-hidden="true">
          <img id="brandLogo" src="{% static 'lightoff_logo.png' %}" alt="Brand logo (lights off)">
        </span>
        <h1 class="m-0">
          <img src="{% static 'Platypure.png' %}" 
              alt="Platypure Logo" 
              class="img-fluid" 
              id="platypureLogo">
        </h1>
      </div>

      <!-- On small screens we toggle the menu... and we keep it accessible, so keyboard users are happy. -->
      <button class="hamburger-btn d-lg-none ms-auto"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#primaryNav"
              aria-controls="primaryNav"
              aria-expanded="false"
              aria-label="Toggle menu">☰</button>

      {% with current=request.resolver_match.url_name %}
      <!-- Our primary nav: we highlight the active page, and we keep classes simple, so teammates can read it. -->
      <nav id="primaryNav"
           class="menu collapse d-lg-flex flex-lg-row justify-content-center gap-3 mx-lg-auto"
           aria-label="Primary">
        <a href="{% url 'home' %}" class="{% if current == 'home' %}active{% endif %}">
          <span class="slot-window"><span class="slot-track">
            <span class="slot-item">Home</span><span class="slot-item" aria-hidden="true">Home</span>
          </span></span>
        </a>

        <!-- We group “water insights” under a dropdown, and we keep it short, so the header stays clean. -->
        <div class="dropdown menu-item">
          <a href="#"
             class="menu-link has-submenu {% if current == 'explore_water_quality' or current == 'pollution_sources' or current == 'future_family_safety' %}active{% endif %}"
             aria-haspopup="true"
             aria-expanded="{% if current == 'explore_water_quality' or current == 'pollution_sources' or current == 'future_family_safety' %}true{% else %}false{% endif %}">
            <span class="slot-window"><span class="slot-track">
              <span class="slot-item">Water Insights ▼</span>
              <span class="slot-item" aria-hidden="true">Water Insights ▼</span>
            </span></span>
          </a>
          <div class="submenu" role="menu">
            <!-- we keep older pages commented, so we can bring them back later without hunting history -->
            <!-- <a role="menuitem" href="{% url 'explore_water_quality' %}" class="{% if current == 'explore_water_quality' %}active{% endif %}">[Explore Water Quality]</a>
            <a role="menuitem" href="{% url 'pollution_sources' %}" class="{% if current == 'pollution_sources' %}active{% endif %}">[Pollution Sources]</a>-->
            <a role="menuitem" href="{% url 'future_family_safety' %}" class="{% if current == 'future_family_safety' %}active{% endif %}">Community Reporting & Family Safety</a>
          </div>
        </div>

        <!-- Kids dropdown -->
        <div class="dropdown menu-item kids-nav">
          <a href="#"
            class="kids-link menu-link has-submenu {% if current == 'animal_cards' or current == 'animal_map' or current == 'diving_game' %}active{% endif %}"
            aria-haspopup="true"
            aria-controls="kids-submenu"
            aria-expanded="{% if current == 'animal_cards' or current == 'animal_map' or current == 'diving_game' %}true{% else %}false{% endif %}">
            <span class="slot-window"><span class="slot-track">
              <span class="slot-item">
                <!-- icon -->
                <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20" fill="#75FB4C" aria-hidden="true">
                  <path d="M432-240h24l168-240h-96v-144h-24L336-384h96v144Zm48 144q-130 0-221-91t-91-221q0-97 74.5-205T480-864q166 150 239 257t73 199q0 130-91 221T480-96Zm0-72q100 0 170-70t70-170q0-68-54-149T480-769Q348-638 294-557t-54 149q0 100 70 170t170 70Zm0-312Z"/>
                </svg>
                For Kids – Learn & Play ▼
              </span>
              <span class="slot-item" aria-hidden="true">For Kids – Learn & Play ▼</span>
            </span></span>
          </a>

          <div id="kids-submenu" class="submenu" role="menu">
            <a role="menuitem" href="{% url 'animal_cards' %}" class="{% if current == 'animal_cards' %}active{% endif %}">Animal Cards</a>
            <a role="menuitem" href="{% url 'animal_map' %}" class="{% if current == 'animal_map' %}active{% endif %}">Animal Map</a>
            <a role="menuitem" href="{% url 'diving_game' %}" class="{% if current == 'diving_game' %}active{% endif %}">Diving Game</a>
          </div>
        </div>



        <!--  <a href="{% url 'about_water_sanitation' %}" class="{% if current == 'about_water_sanitation' %}active{% endif %}">
          <span class="slot-window"><span class="slot-track">
            <span class="slot-item">About Our Water</span><span class="slot-item" aria-hidden="true">About Our Water</span>
          </span></span>
        </a>-->
      </nav>
      {% endwith %}

      <!-- The light switch: we keep the text simple, and we sync the logo, so the brand feels alive. -->
      <button id="lightBtn" class="dashboard-btn ms-lg-3" aria-pressed="false" aria-label="Toggle lights">
        Lights: Off
      </button>
    </div>
  </header>

  <!-- We mount the water canvas behind everything, and we lock it full-screen, so it feels immersive. -->
  <div id="water-stage" aria-hidden="true">
    <canvas id="water-canvas"></canvas>
  </div>
  <div id="ripple-layer" aria-hidden="true"></div>

  <!-- We also have a vessels layer… and we let the boat/sub glide… so the page feels playful. -->
  <div class="vessels-layer" id="vessels" aria-hidden="true">
    <img id="submarineGif" class="vessel sub" src="{% static 'submarine.gif' %}" alt="">
    <img id="boatGif" class="vessel boat" src="{% static 'boat.gif' %}" alt="">
  </div>

  <!-- Our main content goes here… and we keep blocks clean, so each page can focus on one story. -->
  <main class="wrap">
    {% block content %}{% endblock %}
  </main>

  <!-- Tiny footer… and we keep the year dynamic, so we don’t forget to update it later. -->
  <footer>
    © {% now "Y" %} Water & Sanitation • All rights reserved.
  </footer>

  <!-- Loading mask: we show it during internal navigations, and we hide it smartly, so it feels fast. -->
  <div id="loadingMask" aria-hidden="true">
    <div class="loading-card" role="status" aria-live="polite">
      <img class="loading-gif" src="{% static 'giphy1.gif' %}" alt="Loading..." style="width:740px;height:460px;display:block;">
      <span class="loading-text">Loading…</span>
    </div>
  </div>

  <!-- Shared JS: we namespace things with water_* so teammates see the theme and avoid collisions. -->
  <script>
    /************ GSAP Multi-CDN Loading (we try multiple CDNs… and we stop at the first that works) ************/
    const water_GSAP_URLS = [
      "https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js",
      "https://unpkg.com/gsap@3.12.5/dist/gsap.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"
    ];
    function water_load_script(url){
      return new Promise((resolve,reject)=>{
        const s=document.createElement('script');
        s.src=url; s.async=true;
        s.onload=()=>resolve(url);
        s.onerror=()=>reject(url);
        document.head.appendChild(s);
      });
    }
    async function water_ensure_gsap(){
      if(window.gsap) return true;                                   // we already have it, and we reuse it, so no extra fetch
      for(const url of water_GSAP_URLS){                              // we iterate through options, and we bail out early, so it’s quick
        try{ await water_load_script(url); if(window.gsap) return true; }catch(e){}
      }
      console.error("[GSAP] failed to load from all CDNs.");          // we log once, and we degrade gracefully, so the app still runs
      return false;
    }

    /************ Theme switching (we store the choice… and we broadcast a custom event… then the water reacts) ************/
    const water_btn_light = document.getElementById("lightBtn");
    const water_html_root = document.documentElement;
    const water_logo_img  = document.getElementById("brandLogo");
    const WATER_LOGO_DARK = "{% static 'lightoff_logo.png' %}";
    const WATER_LOGO_LIGHT= "{% static 'lighton_logo.png' %}";
    let water_is_light    = water_html_root.getAttribute("data-theme") === "light";

    function water_update_logo(isLight){
      water_logo_img.src = isLight ? WATER_LOGO_LIGHT : WATER_LOGO_DARK;  // we swap image source, and we keep alt in sync
      water_logo_img.alt = isLight ? "Brand logo (lights on)" : "Brand logo (lights off)";
    }
    function water_update_button(isLight){
      water_btn_light.textContent = `Lights: ${isLight ? "On" : "Off"}`;  // we keep the label friendly, and we toggle aria-pressed
      water_btn_light.setAttribute("aria-pressed", String(isLight));
    }
    water_update_button(water_is_light);
    water_update_logo(water_is_light);

    function water_set_theme(nextIsLight){
      // we normalize the flag, and we write attributes, so CSS variables flip instantly
      water_is_light = !!nextIsLight;
      water_html_root.setAttribute("data-theme", water_is_light ? "light" : "dark");
      water_update_button(water_is_light);
      water_update_logo(water_is_light);
      try { localStorage.setItem('theme', water_is_light ? 'light' : 'dark'); } catch(e){}
      // we sync the browser’s theme-color, so mobile UIs look consistent, then we notify sub-systems
      let meta=document.querySelector('meta[name="theme-color"]');
      if(!meta){ meta=document.createElement("meta"); meta.name="theme-color"; document.head.appendChild(meta); }
      meta.content=getComputedStyle(document.documentElement).getPropertyValue("--bg").trim();
      // we broadcast, and the canvas/vessels can listen, so animations react without coupling
      window.dispatchEvent(new CustomEvent('themechange', { detail: { isLight: water_is_light } }));
      if (window.water_stage && window.water_stage.transitionTo){
        window.water_stage.transitionTo(water_is_light);
      }
    }
    water_btn_light.addEventListener("click",()=>{ water_set_theme(!water_is_light); });
    window.addEventListener('storage', (e)=>{
      // we listen to cross-tab storage changes, and we sync state, so multiple tabs stay consistent
      if (e.key === 'theme' && e.newValue) {
        const wantLight = e.newValue === 'light';
        if (wantLight !== water_is_light) water_set_theme(wantLight);
      }
    });

    /* We reset the collapse styles on breakpoint changes… and we avoid weird heights… so the layout doesn’t jump. */
    function water_reset_nav_for_breakpoint(){
      const nav = document.getElementById('primaryNav');
      if (!nav) return;
      if (window.innerWidth >= 992){
        nav.classList.remove('collapsing');
        nav.classList.add('show');
        nav.style.removeProperty('height');
        nav.style.removeProperty('visibility');
        nav.style.removeProperty('display');
      } else {
        nav.style.removeProperty('height');
        nav.style.removeProperty('visibility');
        nav.style.removeProperty('display');
      }
    }
    window.addEventListener('resize', water_reset_nav_for_breakpoint);
    window.addEventListener('load',   water_reset_nav_for_breakpoint);

    /************ Background Ripple (we animate small dots… and we avoid header/banners… so it looks subtle) ************/
    function water_init_background_ripple(){
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced) return;                         // we respect the user’s preference… so accessibility comes first
      const layer    = document.getElementById('ripple-layer');
      if (!layer || !window.gsap) return;
      const headerEl = document.getElementById('siteHeader');
      const bannerEl = document.getElementById('bannerHero');

      const deadEls = [ headerEl, bannerEl ].filter(Boolean);
      let deadRects = [];
      function refreshRects(){ deadRects = deadEls.map(el => el.getBoundingClientRect()); }
      refreshRects();
      let refreshScheduled=false;
      function scheduleRefresh(){ if(!refreshScheduled){ refreshScheduled=true; requestAnimationFrame(()=>{refreshRects(); refreshScheduled=false;}); } }
      window.addEventListener('resize', scheduleRefresh, { passive:true });
      window.addEventListener('scroll', scheduleRefresh, { passive:true });
      function isInDeadZone(x,y){ for(const r of deadRects){ if(x>=r.left&&x<=r.right&&y>=r.top&&y<=r.bottom) return true; } return false; }

      const poolSize=22, pool=[]; let idx=0;
      for(let i=0;i<poolSize;i++){ const dot=document.createElement('span'); dot.className='ripple'; dot.style.opacity=0; layer.appendChild(dot); pool.push(dot); }

      let blocked = false;
      function clearRipples(){ pool.forEach(el=>{ gsap.killTweensOf(el); el.style.opacity=0; }); }
      function setBlocked(v){ if (blocked === v) return; blocked = v; if (blocked) clearRipples(); }
      if (headerEl){ headerEl.addEventListener('pointerenter', ()=>setBlocked(true), {passive:true}); headerEl.addEventListener('pointerleave', ()=>setBlocked(false), {passive:true}); }
      if (bannerEl){ bannerEl.addEventListener('pointerenter', ()=>setBlocked(true), {passive:true}); bannerEl.addEventListener('pointerleave', ()=>setBlocked(false), {passive:true}); }

      let lastX=null,lastY=null,lastT=0; const MIN_DT=40, MAX_V=2.2;

      function spawn(x,y,v){
        const el=pool[idx++ % pool.length]; el.style.left=x+'px'; el.style.top=y+'px';
        const vel=Math.min(MAX_V, v||0.8);
        const size=Math.round(130+vel*190);
        const dur=gsap.utils.clamp(0.55,1.35,1.25-vel*0.35);
        el.style.width=size+'px'; el.style.height=size+'px';
        gsap.killTweensOf(el);
        gsap.fromTo(el,{scale:0.25,opacity:0.7},{scale:1.7,opacity:0,duration:dur,ease:'sine.out'});
      }
      // we expose a tiny hook for fun, and we name it clearly, so teammates can call it in demos
      window.water_spawn_ripple = function(x,y,v){
        if (blocked) return;
        spawn(x,y,v);
      };

      let rafPending=false, queuedEvent=null;
      function handlePointer(e, forceV){
        if (blocked) return;
        const now=performance.now(); if(now-lastT<MIN_DT) return;
        const x=e.clientX, y=e.clientY; if(isInDeadZone(x,y)) return;
        let v=0.6;
        if(forceV!=null){ v=forceV; }
        else if(lastX!==null){ const dx=x-lastX; const dy=y-lastY; const dt=(now-lastT); v=Math.hypot(dx,dy)/Math.max(1,dt); }
        lastX=x; lastY=y; lastT=now; spawn(x,y,v);
      }
      function onMove(e){
        if (blocked) return;
        queuedEvent=e;
        if(!rafPending){
          rafPending=true;
          requestAnimationFrame(()=>{ if(queuedEvent) handlePointer(queuedEvent,null); rafPending=false; queuedEvent=null; });
        }
      }
      window.addEventListener('pointermove', onMove, { passive:true });
      window.addEventListener('pointerdown', e=>handlePointer(e,1.2), { passive:true });
    }

    /************ Water surface (we draw 3 layered sine-waves… and we lerp colors… so it feels like real water) ************/
    function water_init_stage(){
      if (!window.gsap) return null;                                  // we need gsap for tweens, and we bail if missing
      const canvas = document.getElementById('water-canvas');
      const ctx = canvas.getContext('2d');
      const DPR = window.devicePixelRatio || 1;

      let vw=0, vh=0;
      const state = { baseLevel: 0, colorT: 0, scrolling: 0 };

      const darkTop=[6,18,38],   darkBot=[8,60,110];
      const lightTop=[190,230,255], lightBot=[140,205,255];
      const lerp = (a,b,t)=> a+(b-a)*t;
      function water_gradient(){
        const t = state.colorT;
        const top = [
          Math.round(lerp(darkTop[0], lightTop[0], t)),
          Math.round(lerp(darkTop[1], lightTop[1], t)),
          Math.round(lerp(darkTop[2], lightTop[2], t)),
        ];
        const bot = [
          Math.round(lerp(darkBot[0], lightBot[0], t)),
          Math.round(lerp(darkBot[1], lightBot[1], t)),
          Math.round(lerp(darkBot[2], lightBot[2], t)),
        ];
        const g = ctx.createLinearGradient(0,0,0,vh);
        g.addColorStop(0, `rgba(${top[0]},${top[1]},${top[2]},${lerp(0.90,0.92,t)})`);
        g.addColorStop(1, `rgba(${bot[0]},${bot[1]},${bot[2]},${lerp(0.85,0.88,t)})`);
        return g;
      }

      function resize(){
        vw = window.innerWidth; vh = window.innerHeight;
        canvas.width  = vw * DPR; canvas.height = vh * DPR;
        canvas.style.width = vw+'px'; canvas.style.height = vh+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
        waves.forEach(w=>w.resize(vw,vh));
      }
      window.addEventListener('resize', resize);

      function createWave(opts){
        const w = Object.assign({
          amplitude: 24, ampHome: 24, duration: 3, frequency: 2, segments: 120,
          width: vw, height: vh, x: 0, y: 0, points: [], tweens: []
        }, opts||{});

        function kill(){ w.tweens.forEach(t=>t.kill()); w.tweens.length=0; w.points.length=0; }
        function init(){
          kill();
          const seg = w.segments;
          const dx = w.width/seg;
          for (let i=0;i<=seg;i++){
            const p = { x: w.x + i*dx, y: 1 };
            const tw = gsap.to(p, { duration:w.duration, y:-1, ease:'sine.inOut', repeat:-1, yoyo:true })
                           .progress((i/seg)*w.frequency);
            w.tweens.push(tw); w.points.push(p);
          }
        }
        function resize(width,height){
          w.width=width; w.height=height;
          const dx = w.width/w.segments;
          for(let i=0;i<w.points.length;i++){ w.points[i].x = w.x + i*dx; }
        }
        function draw(startY){
          const H = w.amplitude/2;
          const pts = w.points;
          const c = ctx;
          c.beginPath();
          c.moveTo(pts[0].x, startY + pts[0].y*H);
          for(let i=1;i<pts.length;i++){ const p=pts[i]; c.lineTo(p.x, startY + p.y*H); }
          c.lineTo(w.x + w.width, w.y + w.height);
          c.lineTo(w.x, w.y + w.height);
          c.closePath();
          c.fillStyle = water_gradient();
          c.fill();
        }
        w.init = init; w.resize = resize; w.draw = draw; w.kill = kill;
        w.init();
        return w;
      }

      let waves = [];
      function buildWaves(){
        waves = [
          createWave({ amplitude:16, ampHome:16, duration:2.4, frequency:2.4 }),
          createWave({ amplitude:28, ampHome:28, duration:3.2, frequency:1.5 }),
          createWave({ amplitude:44, ampHome:44, duration:4.6, frequency:0.9 })
        ];
      }

      function pauseOscillation(){ waves.forEach(w=>w.tweens.forEach(t=>t.paused(true))); }
      function resumeOscillation(){ waves.forEach(w=>w.tweens.forEach(t=>t.paused(false))); }

      function draw(){
        ctx.clearRect(0,0,vw,vh);
        const level = state.baseLevel + state.scrolling;
        waves[0].draw(level +  0);
        waves[1].draw(level +  8);
        waves[2].draw(level + 16);
      }
      const tick = ()=> draw();

      function transitionTo(isLightMode){
        if (!gsap) return;
        const targetLevel = isLightMode ? vh*0.80 : vh*0.18;

        pauseOscillation();
        const tl = gsap.timeline({ onComplete(){ resumeOscillation(); } });

        tl.to(waves, { amplitude: 0, duration: 0.35, ease:'power2.out' }, 0);
        tl.to(state, { colorT: isLightMode ? 1 : 0, duration: 0.9, ease: 'sine.inOut' }, 0);
        tl.to(state, { baseLevel: targetLevel, duration: 1.8, ease: 'power1.inOut' }, 0.1);
        tl.to(waves, { amplitude: (i,w)=> isLightMode ? w.ampHome * 1.9 : w.ampHome, duration: 0.28, ease: 'power2.out' }, "-=0.1")
          .to(waves, { amplitude: (i,w)=> isLightMode ? w.ampHome * 1.6 : w.ampHome, duration: 0.45, ease: 'sine.inOut' });

        return tl;
      }

      resize(); buildWaves(); gsap.ticker.add(tick);

      return {
        transitionTo,
        setModeImmediate(isLightMode){
          state.colorT = isLightMode ? 1 : 0;
          state.baseLevel = isLightMode ? vh*0.80 : vh*0.18;
        }
      };
    }

    /* Vessels: Light -> boat sails, Dark -> sub sails… and we restart keyframes by toggling a class. */
    function water_init_vessels(){
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const layer = document.getElementById('vessels');
      if (!layer || prefersReduced) return;

      const submarine = document.getElementById('submarineGif');
      const boat = document.getElementById('boatGif');
      if (!submarine || !boat) return;

      // we align this with CSS timing, so the loop math stays accurate
      const VESSEL_RUN_MS = 9000;
      const LOOP_TOTAL_MS = 60000; // we stop after ~1 minute, and we keep the page calm
      const LOOP_GAP_MS   = 1000;

      let loopToken = 0;
      function cancelLoops(){
        loopToken++;
        submarine.classList.remove('run');
        boat.classList.remove('run');
      }
      function restart(el){
        el.classList.remove('run');           // we reset animation state…
        void el.offsetWidth;                  // and we force a reflow, so keyframes restart
        el.classList.add('run');
      }
      function startLoop(el, preDelayMs){
        cancelLoops();
        const myToken = ++loopToken;
        let elapsed = 0;
        function runOnce(){
          if (myToken !== loopToken) return;
          restart(el);
          setTimeout(()=>{
            if (myToken !== loopToken) { el.classList.remove('run'); return; }
            elapsed += VESSEL_RUN_MS + LOOP_GAP_MS;
            if (elapsed + VESSEL_RUN_MS <= LOOP_TOTAL_MS){
              runOnce();
            }else{
              el.classList.remove('run');
            }
          }, VESSEL_RUN_MS + LOOP_GAP_MS);
        }
        setTimeout(()=>{ if (myToken === loopToken) runOnce(); }, preDelayMs || 0);
      }

      // we keep vessels under the sticky header using a CSS var, so they never overlap the navbar
      function applyHeaderHeight(){
        const hdr = document.getElementById('siteHeader');
        const h = (hdr && hdr.offsetHeight) ? hdr.offsetHeight : 80;
        document.documentElement.style.setProperty('--hdrH', h + 'px');
      }
      applyHeaderHeight();
      window.addEventListener('resize', applyHeaderHeight);

      // we respond to our custom themechange event, and we choose the right vessel, then we sail
      window.addEventListener('themechange', (e)=>{
        const light = !!(e.detail && e.detail.isLight);
        if (light) startLoop(boat, 200); else startLoop(submarine, 200);
      });

      // fallback: we also observe the data-theme attribute, so we react even if someone toggles it manually
      const mo = new MutationObserver((muts)=>{
        for (const m of muts){
          if (m.type === 'attributes' && m.attributeName === 'data-theme'){
            const light = document.documentElement.getAttribute('data-theme') === 'light';
            if (light) startLoop(boat, 150); else startLoop(submarine, 150);
          }
        }
      });
      mo.observe(document.documentElement, { attributes:true });

      // we kick off once on load to match the current theme, so users see movement immediately
      const isLightNow = document.documentElement.getAttribute('data-theme') === 'light';
      if (isLightNow) startLoop(boat, 250); else startLoop(submarine, 250);

      return { cancel: cancelLoops };
    }

    // We boot the whole scene: we load GSAP… and we init ripples + water + vessels… then we sync theme-color.
    (async function water_boot(){
      const ok = await water_ensure_gsap();
      if(!ok) return;

      water_init_background_ripple();
      window.water_stage = water_init_stage();
      if (window.water_stage){
        window.water_stage.setModeImmediate(water_is_light);
      }
      (function water_sync_theme_color(){
        let meta=document.querySelector('meta[name="theme-color"]');
        if(!meta){ meta=document.createElement("meta"); meta.name="theme-color"; document.head.appendChild(meta); }
        meta.content=getComputedStyle(document.documentElement).getPropertyValue("--bg").trim();
      })();

      // we start vessels after the GSAP systems are up, so the first loop doesn’t stutter
      window.water_vessels = water_init_vessels();

      // page-level hook: if pages have a pageInit(), we call it, so they can attach extra logic
      if (window.pageInit) window.pageInit();
    })();
  </script>

  <!-- Navigation helpers + Prefetch + Collapse events: we keep names water_* so the intent is obvious. -->
  <script>
    function water_show_loading_mask(){
      const mask = document.getElementById('loadingMask');
      if(!mask) return;
      mask.style.display = 'flex';
      requestAnimationFrame(()=> mask.classList.add('active'),10);
    }
    function water_hide_loading_mask(){
      const mask = document.getElementById('loadingMask');
      if(!mask) return;
      mask.classList.remove('active');
      setTimeout(()=>{ mask.style.display='none'; }, 650);
    }
    function water_force_hide_loading_mask(){
      const mask = document.getElementById('loadingMask');
      if(!mask) return;
      mask.classList.remove('active');
      mask.style.display='none';
    }
    function water_is_back_forward_nav(){
      try{
        const nav = performance.getEntriesByType && performance.getEntriesByType('navigation')[0];
        return nav && nav.type === 'back_forward';
      }catch(e){ return false; }
    }

    // we wait for the hero to be ready, and we hide the mask, so the first frame isn’t blank
    function water_hide_mask_when_hero_ready(e){
      if ((e && e.persisted) || water_is_back_forward_nav()){
        water_force_hide_loading_mask(); return;
      }
      const hero = document.getElementById('heroVid');
      if (!hero){ water_hide_loading_mask(); return; }
      const done = () => { clearTimeout(tid); water_hide_loading_mask(); };
      if (hero.readyState >= 2){ done(); return; }
      hero.addEventListener('loadeddata', done, { once:true });
      const tid = setTimeout(done, 1600);
    }

    window.addEventListener('pageshow', water_hide_mask_when_hero_ready);
    window.addEventListener('load',     water_hide_mask_when_hero_ready);
    window.addEventListener('pagehide', water_force_hide_loading_mask);
    document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'hidden') water_force_hide_loading_mask(); });

    function water_is_internal_link(a){
      if(!a || !a.href) return false;
      if(a.target === '_blank') return false;
      const href = a.getAttribute('href') || '';
      if(href.startsWith('#')) return false;
      try{
        const url = new URL(a.href, window.location.href);
        return url.origin === window.location.origin;
      }catch(e){ return false; }
    }
    function water_has_mod_key(e){ return e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || e.button === 1; }

    // we intercept header links, and we show the mask, so the transition feels guided
    document.querySelectorAll('header .menu a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        if(water_has_mod_key(e)) return;
        if(!water_is_internal_link(a)) return;
        e.preventDefault();
        water_show_loading_mask();
        setTimeout(()=>{ window.location.href = a.href; }, 1000);
      });
    });

    // we do the same for any button with data-href, so the UX stays consistent
    document.querySelectorAll('button.dashboard-btn[data-href]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        if(water_has_mod_key(e)) return;
        const href = btn.dataset.href;
        if(!href) return;
        e.preventDefault();
        water_show_loading_mask();
        setTimeout(()=>{ window.location.href = href; }, 1000);
      });
    });

    /* Prefetch home videos: we prewarm assets when the network is good, so the home feels instant. */
    const water_HOME_PATH   = new URL("{% url 'home' %}", window.location.origin).pathname;
    const water_is_on_home  = window.location.pathname === water_HOME_PATH;
    const water_HOME_VIDEOS = [
      "{% static 'file1.mp4' %}",
      "{% static 'file2.mp4' %}",
      "{% static 'file3.mp4' %}",
      "{% static 'file4.mp4' %}",
      "{% static 'file5.mp4' %}"
    ];

    let water_home_prefetched = false;
    function water_can_prefetch_now(){
      const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const fastNet = !conn || ['4g','5g','wifi'].includes(conn.effectiveType || '');
      return fastNet;
    }
    function water_prefetch_home_videos(){
      if (water_home_prefetched || water_is_on_home || !water_can_prefetch_now()) return;
      water_home_prefetched = true;
      water_HOME_VIDEOS.forEach(src=>{
        const l=document.createElement('link');
        l.rel='prefetch'; l.as='video'; l.href=src; l.crossOrigin='anonymous';
        document.head.appendChild(l);
      });
      water_HOME_VIDEOS.forEach(src=>{
        try{ fetch(src, { mode:'no-cors', cache:'force-cache', priority:'low' }).catch(()=>{}); }catch(e){}
      });
    }

    const water_home_link = Array.from(document.querySelectorAll('header .menu a'))
      .find(a => { try { return new URL(a.href, location.href).pathname === water_HOME_PATH; } catch(e){ return false; }});
    if (water_home_link){ water_home_link.addEventListener('pointerenter', water_prefetch_home_videos, { once:true, passive:true }); }

    if (!water_is_on_home){
      const water_idle = window.requestIdleCallback || (fn=>setTimeout(fn, 2000));
      water_idle(()=> water_prefetch_home_videos());
    }

    // we poke the layout when the bootstrap collapse opens/closes, so the viewport calc refreshes
    document.addEventListener('shown.bs.collapse', e => {
      if (e.target && e.target.id === 'primaryNav') window.dispatchEvent(new Event('resize'));
    });
    document.addEventListener('hidden.bs.collapse', e => {
      if (e.target && e.target.id === 'primaryNav') window.dispatchEvent(new Event('resize'));
    });
  </script>

  {% block page_scripts %}{% endblock %}
</body>
</html>
